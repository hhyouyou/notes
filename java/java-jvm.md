[TOC]

# Jvm


jvm有哪些点？
## 一、运行时数据区域

### 程序计数器 program counter register

**线程私有**

记录当前线程正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法native则为空）

**在这里，其实有两个“当前”，一个是：当前正在被 CPU 执行的线程，另一个是：当前这个被执行的线程中正在被执行的字节码指令**。**字节码解释器工作时就是改变程序计数器的值来选取下一条需要执行的字节码**。

线程切换后，能恢复到正在执行的字节码的位置，所以每个线程都需要有自己的程序计数器。

### 虚拟机栈 vm stack

每个Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在Java虚拟机栈中的入栈和出栈的过程。

条线程都有一个独立的栈（VM Stack）。每个方法执行时都会创建一个栈帧，也就是说，当有一条线程执行多个方法的时候，就有一个栈，栈中有多个栈帧。

> Java 虚拟机规范中规定了虚拟机栈可能出现的两种异常状况：StackOverflowError 和 OutOfMemoryError。
>
> StackOverflowError：若当前线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候就会抛出StackOverflowError
>
> OutOfMemoryError ： 若虚拟机栈动态扩展过程中，如果线程请求空间无法申请到足够的内存，就会抛出 OutOfMemoryError

### 本地方法栈 native method stack

**线程私有**

本地方法栈与虚拟机栈类似，虚拟机栈是执行Java 方法开辟的内存空间，而本地方法栈是执行Native方法开辟的内存空间。与虚拟机栈一样，本地方法栈也会抛出这两个异常，条件也是类似的。



### 堆 heap

堆是所有线程共享的一块区域，主要用来存放对象和数组。

在Java 虚拟机规范中有描述，所有的对象实例和数组都要在堆上分配，但是随着 JIT(JUST-IN-TIME)编译器的发展与逃逸分析技术的逐渐成熟，并不是所有对象都只在堆上分配了，比如：随着逃逸分析技术的逐渐成熟，在即时能被回收的对象也有可能在虚拟机栈上分配。

由于现在都采用分代回收算法，所以从内存回收的角度看，堆还可以细分为 ： 新生代、老年代。

新生代有可以分为：Eden空间、From Survivor 空间，To Survivor空间



### 方法区 method area

 方法区 和堆一样也是所有线程共享的一块区域，主要用来存储已经被虚拟机加载的类信息、常量、静态变量、即使编译器（JIT）编译后产生的代码等数据。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却又一个别名叫做Non-heap非堆，用以区分堆。



### 运行时常量池 runtime constant pool

在1.7以及之后的版本，已经从方法区种移除。在堆heap中开辟了一块区域存放运行时常量池。

运行时常量池主要存字面量和符号引用

字面量：常量、静态变量等

符号引用：类的完全限定名、字段名称和描述符、方法名称和描述符

### 直接内存 direct memory

直接内存并不是jvm运行时数据区的一部分，也不是虚拟规范中定义的内存区，但是这部分内存也被频繁使用。而且可能会导致oom。





  





### 参考资料

[在Java虚拟机中，字符串常量到底存放在哪](https://juejin.im/post/5c3d3121e51d4551741171fe)

[java运行时数据区](https://juejin.im/post/6844904119497392141)