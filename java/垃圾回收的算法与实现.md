[TOC]





# 垃圾回收的算法与实现





## GC的定义

GC是Garbage Collection的简称，中文称为“垃圾回收”。



![I'm gc](https://image-hhyy.oss-cn-hangzhou.aliyuncs.com/md/imgc.png)







### 回收什么垃圾？

一般我们说的”垃圾“，指的是我们不需要用的东西。

Garbage Collection中的Garbage，指的就是程序用不着的内存空间。



### GC要做的事情

1.  找到内存空间中的垃圾
2. 回收垃圾，让程序能再次利用这部分空间



### GC的好处

#### 如果没有GC?

如果没有GC? 像我们最早学C语言的时候，需要我们手动进行内存管理，申请内存、释放内存。

一般来讲，申请空间没啥大问题，但是要保证把所有不用的空间都及时释放，就比较困难。很容易发生内存泄漏，也就是空间一直被无效占用，无法被使用，内存逐渐被占满，最终可能导致系统崩溃。

除此之外，在释放内存空间时，如果忘记初始化指向释放对象的内存空间的指针，这个指针就会一直指向释放完毕的内存空间。因为这个指针没有指向有效的内存空间，处于一种悬挂状态，所以我们称其为“悬垂指针”（dangling pointer）。如果程序引用了这个悬垂指针，可能导致一些奇怪的bug，也可能导致严重的安全漏洞。









## 垃圾回收算法



### Readying

头(header)：将对中保存对象本身信息的部分成为“头”。例如，对象的大小/种类

域(field)：对象内容。包括指针和非指针

![对象](https://image-hhyy.oss-cn-hangzhou.aliyuncs.com/md/gc-object.png)

堆：存放对象的内存空间。GC就是管理堆中已分配对象的机制。

活动对象/非活动对象：将分配到内存空间中对象的对象中，任然被应用程序应用的对象成为活动对象。反之则是非活动对象

分配(allocation)：在内存空间中，选一块分配给对象。Java/Ruby等有GC的语言在生成实例时，会在内部分配。而C/C++等，需要手动使用malloc()去申请内存。

分块(chunk): 为对象事先准备的空间。



### 评价标准

评价GC算法的性能

* 吞吐量：单位时间内的处理能力
* 最大暂停时间：应执行GC而暂停执行应用的最长时间
* 堆使用效率
* 访问的局部性：具有引用关系的对象之间存在联系访问的情况，尽可能的放在堆中较进的位置。



> Tips:
>
> PC上有4种存储器，寄存器、缓存、内存(主存储器)、辅助存储器（硬盘等）
>
> 容量：寄存器<<缓存<<内存<<辅助存储器
>
> 处理速度：寄存器>>缓存>>内存>>辅助存储器
>
> 众所周知，越是可实现高速存取的存储器容量就越小。毫无疑问，我们都希望尽可能地利用较高速的存储器，但由于高速的存储器容量小，因此通常不可能把所有要利用的数据都放在寄存器和缓存里。一般我们会把所有的数据都放在内存里，当CPU访问数据时，仅把要使用的数据从内存读取到缓存。与此同时，我们还将它附近的所有数据都读取到缓存中，从而压缩读取数据所需要的时间。







### 1. GC标记-清除算法



#### 1.1 what?

顾名思义，标记-清除算法是由标记阶段和清除阶段构成。

1. 标记阶段：会把所有活动对象都做上标记

2. 清除阶段：会把没有被标记的对象，也就是非活动对象回收的掉

```java
mark_sweep(){
	mark_phase();
	sweep_phase();
}
```

![gc执行前堆状态](https://image-hhyy.oss-cn-hangzhou.aliyuncs.com/md/gc1.png)



#### 1.2 标记阶段

`mark_phase()` 伪代码如下

```c
mark_phase(){
	for(r : $roots){
		mark(*r)
	}
}
```

在标记阶段，gc会为堆中所有的活动标记打上标记。

那么，从哪里开始呢？我们一般从根直接引用的对象开始（这个对象就是，活动对象）。然后递归的标记通过指针数组能访问到的对象。这样就能把所有活动对象都标记上了。

下面是mark()函数

```c
mark(obj){
	if (obj.mark == false) {
		obj.mark = true;
        for (child : children(obj)){
            mark(*child)
        }
	}
}
```

标记过程中，先判断是否被标记，如果没有被标记。就在对现象的头部进行标记。

![](https://image-hhyy.oss-cn-hangzhou.aliyuncs.com/md/gc2.png)

标记完所有活动对象后，标记阶段就结束了。



#### 1.3 清除阶段

在清除阶段，gc会遍历整个堆，回收没有打上标记的对象（垃圾），使其能再次得到利用。

```c
sweep_phase(){
    sweeping = $heap_start // 从堆起始点开始
    while(sweeping < $heap_end){ // 遍历整个堆
        if(sweeping.mark == TRUE){  // 活跃状态直接过
            sweeping.mark = FALSE
        } else {
            sweeping.next = $free_list  // 关联到空闲链表
            $free_list = sweeping
        }
        sweeping += sweeping.size // 下一块
    }
}
```

清除阶段，会遍历堆，所以花费的时间，和堆的大小成正比。



#### 1.4 分配内存

垃圾回收完毕后，需要将回收后的块再次利用。那么，在malloc申请内存的时候，如何把合适的块找出来呢？

在上面的清除阶段中，我们已经把垃圾对象都连接到空闲链表了。而搜索空闲链表，并寻找大小合适的分块，这步操作就叫做分配。

执行分配操作的伪代码new_obj()如下：

```c
new_obj(size){
    chunk = pickup_chunk(size, $free_list);// 选择大小合适的块
    if (chunk != null){
        return chunk;
    } else {
        allocation_fail();
    }
}
```



> Tips:
>
> 在pickup_chunk()的时候也有多种策略:
>
> First-fit: 找到大于等于size的分块时立即返回，然后分割成合适大小
>
> Best-fit: 遍历空闲链表，返回大于等于size的最小分块
>
> Worst-fit: 找出空闲链表中最大的分块，分割出合适的分块



#### 1.5 合并



#### 1.6 优点 & 缺点

优点：

* 实现起来简单
* 与保守式GC算法兼容

> 在保守式算法中，对象是不能被移动的。



缺点：

* 碎片化
* 分配速度
* 与写时复制技术不兼容



#### 1.7 优化



##### 1.7.1 清除时合并空间

根据分配策略不用，可能会产生大量的小分块。但是如果我们在清除的过程中直接把连续的空间合并，就可以更好的利用空间。

下面是执行合并的sweep_phase()伪代码：

```c
sweep_phase(){
    sweeping = $heap_start 
    while(sweeping < $heap_end){
        if(sweeping.mark == TRUE){ 
            sweeping.mark = FALSE
        } else {
            // 如果这次发现的分块和上次发现的分块连续
            if (sweeping == $free_list + $free_list.size) {
                // 则将两个分块整理成一个分块合并到空闲链表
                $free_list.size += sweeping.size
            } else {
                sweeping.next = $free_list 
           		$free_list = sweeping
            }
        }
        sweeping += sweeping.size 
    }
}
```



###### 1.7.2 多个空闲链表





##### 1.7.3 BIBOP法



##### 1.7.4 位图标记法



##### 1.7.5 延迟清除法







### 引用计数法



### GC复制算法



### GC标记-压缩算法



### 保守式GC



### 分代垃圾回收



### 增量式垃圾回收



### RC Immix算法











## Java的GC





