## 第一章   简单工厂



## 第二章   策略模式

封装算法

## 第三章   单一指责原则



## 第四章   开放-封闭原则



## 第五章   依赖倒转原则



## 第六章   装饰模式



* 装饰模式是用来：**动态的给对象加上额外的职责**



#### 使用到的地方

1.  Spring中BeanDefinitionDecorator
2.  commons-collections包中ListUtils



#### 装饰模式和继承的区别

* 装饰者模式强调的是**动态**的扩展, 而继承关系是**静态的**.
* **组合优于继承**



#### 装饰和建造者

* Builder模式是一种**创建型**的设计模式. **旨在解决对象的差异化构建的问题**.
* 装饰者模式是一种**结构型**的设计模式. **旨在处理对象和类的组合关系**.



> Builder模式的**差异化构建**是**可预见**的, 而装饰者模式实际上提供了一种不可预见的扩展组合关系.



对象，ProductInfoVo， 本来只有商品的 id、 name

但是我还需要他的 库存信息？ 加上 stock信息

还需要供应信息？加上供应商信息

还需要操作人信息？加上操作人信息

唉好像思路不对



#### 使用场景

* 在不改变原有类结构基础上，新增或者限制或者改造功能时候。





## 第七章 代理模式



**代理模式**（proxy）， 为其他对象提供一种代理以控制对这个对象的访问。



 #### 应用场景

1. 远程代理 ：为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实
2. 虚拟代理 ：根据需要创建开销很道德对象。通过它来存放实例化需要很长时间的真实对象
3. 安全代理 ：安全代理，用来控制真实对象访问时的权限
4. 智能指引 ： 是指当调用真实对象时，代理处理另外一些事









## 适配器模式



> 对已有的方法进行兼容
>
> 在方法外再封装一层，让新的接口，可以复用老的代码



在spring中的使用， 实现AdvisorAdapter, 的三个适配器





## 备忘录模式

参考https://juejin.im/post/5bd12141f265da0ad82c4f71





**Originator（原发器）**：它是一个普通类，可以创建一个备忘录，并存储它的当前内部状态，也可以使用备忘录来恢复其内部状态，一般将需要保存内部状态的类设计为原发器。

**Memento（备忘录)**：存储原发器的内部状态，根据原发器来决定保存哪些内部状态。备忘录的设计一般可以参考原发器的设计，根据实际需要确定备忘录类中的属性。需要注意的是，除了原发器本身与负责人类之外，备忘录对象不能直接供其他类使用，原发器的设计在不同的编程语言中实现机制会有所不同。

**Caretaker（负责人）**：负责人又称为管理者，它负责保存备忘录，但是不能对备忘录的内容进行操作或检查。在负责人类中可以存储一个或多个备忘录对象，它只负责存储对象，而不能修改对象，也无须知道对象的实现细节。

备忘录模式的核心是备忘录类以及用于管理备忘录的负责人类的设计。





### 备忘录模式总结

备忘录模式的**主要优点**如下：

- 它提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原。
- 备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动。备忘录保存了原发器的状态，采用列表、堆栈等集合来存储备忘录对象可以实现多次撤销操作。

备忘录模式的**主要缺点**如下：

- 资源消耗过大，如果需要保存的原发器类的成员变量太多，就不可避免需要占用大量的存储空间，每保存一次对象的状态都需要消耗一定的系统资源。

**适用场景**：

- 保存一个对象在某一个时刻的全部状态或部分状态，这样以后需要时它能够恢复到先前的状态，实现撤销操作。
- 防止外界对象破坏一个对象历史状态的封装性，避免将对象历史状态的实现细节暴露给外界对象。





可以用在前端？？？

我觉得前端更合适一点，后端更适合数据的持久化，应该说是后台

前端页面上，可以对某些东西，编辑然后撤销，最后决定好了，在持久化到后台就可以了

后端没啥用







## 组合模式





## 迭代器模式



参考: https://juejin.im/post/5bbf67e86fb9a05d3447e054





### 迭代器模式

**迭代器模式(Iterator Pattern)**：提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(Cursor)。迭代器模式是一种对象行为型模式



#### 角色

**Iterator（抽象迭代器）**：它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法，例如：用于获取第一个元素的first()方法，用于访问下一个元素的next()方法，用于判断是否还有下一个元素的hasNext()方法，用于获取当前元素的currentItem()方法等，在具体迭代器中将实现这些方法。

**ConcreteIterator（具体迭代器）**：它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时，游标通常是一个表示位置的非负整数。

**Aggregate（抽象聚合类）**：它用于存储和管理元素对象，声明一个createIterator()方法用于创建一个迭代器对象，充当抽象迭代器工厂角色。

**ConcreteAggregate（具体聚合类）**：它实现了在抽象聚合类中声明的createIterator()方法，该方法返回一个与该具体聚合类对应的具体迭代器ConcreteIterator实例。

在迭代器模式中，提供了一个外部的迭代器来对聚合对象进行访问和遍历，迭代器定义了一个访问该聚合元素的接口，并且可以跟踪当前遍历的元素，了解哪些元素已经遍历过而哪些没有。迭代器的引入，将使得对一个复杂聚合对象的操作变得简单。

在迭代器模式中应用了工厂方法模式，抽象迭代器对应于抽象产品角色，具体迭代器对应于具体产品角色，抽象聚合类对应于抽象工厂角色，具体聚合类对应于具体工厂角色。



## 中介者模式

[http://laijianfeng.org/2018/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8/](http://laijianfeng.org/2018/10/设计模式-中介者模式及典型应用/)





同一层级，多个服务互相调用，造成混乱。

由一个中间人，统一调度



java.util.Timer