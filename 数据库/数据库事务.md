[TOC]

# 数据库相关概念



## 事务

### 概念

**事务**是指满足`ACID`特性的一组操作. 而`ACID`模型是一组数据库设计原则，用于保证数据的可靠性

![事务](http://image-djx.test.upcdn.net/md/notes/transaction.png)

### ACID

#### 1. A: 原子性 atomicity 

事务被视为不可分割的最小单元, 事务的所有操作要么全部成功,要么都失败回滚.

回滚(rollback)可以用回滚日志(Undo Log)来实现,    回滚日志记录着事务所执行的修改操作, 在回滚时反向执行这些修改操作.

#### 2. C: 一致性 consistency

数据库在事务执行前后保持一致性状态. 在一致性状态下,所有事务对同一 数据的读取都是相同的.

#### 3. I:  隔离性 isolation

一个事务所做的修改在提交之前,  对其他事务是不可见的.

#### 4. D:  持久性 durability

一旦事务提交, 则其所做的修改会永久保存到数据库. 即使系统崩溃, 事务执行的结果也不能丢失.

系统发生崩溃可以用redo log (重做日志) 进行恢复, 从而实现持久性.



事务的ACID特性比较简单 , 但是特性互相之间的关系并不是平级的

* 只有满足一致性, 事务的执行结果才是正确的.

* 在非并发场景下, 事务串行执行, 隔离性是一定能满足的. 此时只要满足原子性,就一定能满足一致性
* 在并发场景下, 多个事务并行执行,此时事务要同时满足隔离性,和原子性, 才能满足一致性
* 而最后的持久性, 主要适用于系统崩溃的情况. 



## 并发一致性问题

并发情况下,无法保证隔离性,出现的一些一致性问题.

### 修改丢失

修改丢失指的是, 一个事务修改了某个数据后, 被另一个事务的修改覆盖.

例如, `T1` 和`T2`两个事务都修改同一库存数量,`T1`先修改并提交生效, `T2`随后修改, `T2`的修改覆盖了`T1`的修改.

### 脏读

脏读指的是, 读取到脏数据. 当前事务读取到了其他事务未提交的数据.

例如, `T1`修改了一个数据, `T2`随后读取到了这个未提交的数据, 接下来 `T1`提交失败,回滚了数据, `T2`读取到的这个数据就是脏数据.

### 不可重复读

不可重复读指的是在一个事务内多次读取同一数据.  在该事务未提交时, 另一事务对该数据做了修改,导致第一个事务再次读取同一数据值不一致. 

例如, `T1` 读取一商品库存数量, 在事务未提交期间, `T2`增加了库存数量. 此时, `T1`再次读取库存数量, 发现和第一次读取的不一致.

### 幻读

幻读和不可重复读类似, 不可重复读只的是同一数据值多次读取不一致. 幻读则是,多次读取范围数据, 数量不一致.

例如, `T1`查询某个品类的商品库存, `T2`在这个品类内插入新的商品, `T1`再次查询该品类的商品库存, 发现和第一次读取的数量不一致.

> 产生并发不一致性问题的主要原因是事务的隔离性被破坏. 并发控制可以通过加锁来解决, 但是锁的操作比较复杂. 所以数据提供了事务的隔离级别, 让用户在使用时, 更好的处理并发一致性问题



## 事务隔离级别

### 读未提交(Read Uncommitted ) 

事务能读取到其他事务未提交的数据. 也就是说, 事务中的修改, 即使未提交, 对其他事务也是可见的.

### 读已提交(Read Committed)

在一个事务内, 能读取到其他事务已经提交的修改. 也就是说, 事务的修改在提交前对其他事务是不可见, 在提交后对其他事务可见.

### 可重复读( Repeatable Read)

在一个事务内, 多次读取同一数据的值是一致的. 也就是说, 在`T1`事务内读取数据, 即使`T2`事务修改同一数据并提交了,对`T1`事务也没有影响,读到的数据还是不会变动.

### 可串行化(Serializable)

强制多个事务串行执行, 就不会出现并发一致性问题.

该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。

### 隔离级别对应解决的并发一致性问题

|              | 脏读 | 不可重复读 | 幻读 |
| :----------: | :--: | :--------: | :--: |
| **读未提交** |  ×   |     ×      |  ×   |
| **读已提交** |  √   |     ×      |  ×   |
| **可重复读** |  √   |     √      |  ×   |
| **可串行化** |  √   |     √      |  √   |



## 锁

### 锁粒度

MySQL中提供了两种锁粒度: 行级锁和表级锁

> 在选择锁粒度时, 需要考虑锁的开销和并发程度.
>
> 锁的开销:加速需要消耗一定资源, 检查锁状态, 获取锁, 释放锁都会增加开销. 因此锁的粒度越小,系统开销越小. 
>
> 并发程度: 锁定的数据越小,锁之间竞争的情况越少,并发程度就越高.

### 锁类型

#### 1. 读写锁

* 互斥锁(Exclusive), 又称写锁
* 共享锁(Shared), 又称读锁

顾名思义, 互斥锁/写锁, 一个事务对数据加上互斥锁后, 可以对该数据读写. 同时其他事务无法对该数据加锁读写.

共享锁/读锁, 一个事务对数据加上共享锁后,只能读取该数据,无法修改数据. 同时,其他事务能对该数据加读锁, 但是不能加写锁.

**锁的兼容关系**

|                 | 互斥锁/写锁 | 共享锁/读锁 |
| :-------------: | :---------: | :---------: |
| **互斥锁/写锁** |      ×      |      ×      |
| **共享锁/读锁** |      ×      |      √      |



#### 2. 意向锁







## 并发版本控制(MVCC)





## 关系数据库设计理论





# 参考文章



